<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<refentry id="libenca-Internal-Functions">
<refmeta>
<refentrytitle>internal</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>LIBENCA Library</refmiscinfo>
</refmeta>

<refnamediv>
<refname>internal</refname><refpurpose>
<para>
internal functions
</para></refpurpose>
</refnamediv>

<refsynopsisdiv><title>Synopsis</title>

<synopsis>



struct      <link linkend="EncaAnalyserOptions">EncaAnalyserOptions</link>;
struct      <link linkend="EncaAnalyserState">EncaAnalyserState</link>;
struct      <link linkend="EncaCharsetInfo">EncaCharsetInfo</link>;
struct      <link linkend="EncaLanguageInfo">EncaLanguageInfo</link>;
struct      <link linkend="EncaLanguageHookData1CS">EncaLanguageHookData1CS</link>;
struct      <link linkend="EncaLanguageHookDataEOL">EncaLanguageHookDataEOL</link>;
int         (<link linkend="EncaHookFunc">*EncaHookFunc</link>)                 (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
int         (<link linkend="EncaGuessFunc">*EncaGuessFunc</link>)                (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
struct      <link linkend="EncaUTFCheckData">EncaUTFCheckData</link>;
#define     <link linkend="ELEMENTS-CAPS">ELEMENTS</link>                        (array)
#define     <link linkend="MAKE-HOOK-LINE-CAPS">MAKE_HOOK_LINE</link>                  (name)
#define     <link linkend="EPSILON-CAPS">EPSILON</link>
#define     <link linkend="FILL-NONLETTER-CAPS">FILL_NONLETTER</link>
#define     <link linkend="LF-CAPS">LF</link>
#define     <link linkend="CR-CAPS">CR</link>
void*       <link linkend="enca-malloc">enca_malloc</link>                     (<link linkend="size-t">size_t</link> size);
void*       <link linkend="enca-realloc">enca_realloc</link>                    (void *ptr,
                                             <link linkend="size-t">size_t</link> size);
#define     <link linkend="enca-free">enca_free</link>                       (ptr)
#define     <link linkend="NEW-CAPS">NEW</link>                             (type,n)
#define     <link linkend="RENEW-CAPS">RENEW</link>                           (ptr,type,n)
char*       <link linkend="enca-strdup">enca_strdup</link>                     (const char *s);
const char* <link linkend="enca-strstr">enca_strstr</link>                     (const char *haystack,
                                             const char *needle);
char*       <link linkend="enca-stpcpy">enca_stpcpy</link>                     (char *dest,
                                             const char *src);
char*       <link linkend="enca-strconcat">enca_strconcat</link>                  (const char *str,
                                             ...);
char*       <link linkend="enca-strappend">enca_strappend</link>                  (char *str,
                                             ...);
#define     <link linkend="enca-csname">enca_csname</link>                     (cs)
int         <link linkend="enca-name-to-charset">enca_name_to_charset</link>            (const char *csname);
<link linkend="EncaSurface">EncaSurface</link> <link linkend="enca-name-to-surface">enca_name_to_surface</link>            (const char *sname);
int         <link linkend="enca-language-init">enca_language_init</link>              (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             const char *langname);
void        <link linkend="enca-language-destroy">enca_language_destroy</link>           (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
<link linkend="double">double</link>*     <link linkend="enca-get-charset-similarity-matrix">enca_get_charset_similarity_matrix</link>
                                            (const <link linkend="EncaLanguageInfo">EncaLanguageInfo</link> *lang);
int         <link linkend="enca-charsets-subset-identical">enca_charsets_subset_identical</link>  (int charset1,
                                             int charset2,
                                             const <link linkend="size-t">size_t</link> *counts);
<link linkend="size-t">size_t</link>      <link linkend="enca-filter-boxdraw">enca_filter_boxdraw</link>             (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             unsigned char fill_char);
int         <link linkend="enca-language-hook-ncs">enca_language_hook_ncs</link>          (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             <link linkend="size-t">size_t</link> ncs,
                                             <link linkend="EncaLanguageHookData1CS">EncaLanguageHookData1CS</link> *hookdata);
int         <link linkend="enca-language-hook-eol">enca_language_hook_eol</link>          (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             <link linkend="size-t">size_t</link> ncs,
                                             <link linkend="EncaLanguageHookDataEOL">EncaLanguageHookDataEOL</link> *hookdata);
void        <link linkend="enca-guess-init">enca_guess_init</link>                 (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
void        <link linkend="enca-guess-destroy">enca_guess_destroy</link>              (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
<link linkend="EncaSurface">EncaSurface</link> <link linkend="enca-eol-surface">enca_eol_surface</link>                (unsigned char *buffer,
                                             <link linkend="size-t">size_t</link> size,
                                             const <link linkend="size-t">size_t</link> *counts);
void        <link linkend="enca-find-max-sec">enca_find_max_sec</link>               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-BE-CAPS">ENCA_LANGUAGE_BE</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-BG-CAPS">ENCA_LANGUAGE_BG</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-CS-CAPS">ENCA_LANGUAGE_CS</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-ET-CAPS">ENCA_LANGUAGE_ET</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-HR-CAPS">ENCA_LANGUAGE_HR</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-HU-CAPS">ENCA_LANGUAGE_HU</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-LT-CAPS">ENCA_LANGUAGE_LT</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-LV-CAPS">ENCA_LANGUAGE_LV</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-PL-CAPS">ENCA_LANGUAGE_PL</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-RU-CAPS">ENCA_LANGUAGE_RU</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-SK-CAPS">ENCA_LANGUAGE_SK</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-SL-CAPS">ENCA_LANGUAGE_SL</link>;
extern      const EncaLanguageInfo <link linkend="ENCA-LANGUAGE-UK-CAPS">ENCA_LANGUAGE_UK</link>;
void        <link linkend="enca-double-utf8-init">enca_double_utf8_init</link>           (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
void        <link linkend="enca-double-utf8-destroy">enca_double_utf8_destroy</link>        (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
void        <link linkend="enca-pair-init">enca_pair_init</link>                  (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
void        <link linkend="enca-pair-destroy">enca_pair_destroy</link>               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
int         <link linkend="enca-pair-analyse">enca_pair_analyse</link>               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);
</synopsis>
</refsynopsisdiv>







<refsect1>
<title>Description</title>
<para>
Do not use outside Enca library.
</para>
</refsect1>

<refsect1>
<title>Details</title>
<refsect2>
<title><anchor id="EncaAnalyserOptions"/>struct EncaAnalyserOptions</title>
<programlisting>struct EncaAnalyserOptions {

  int const_buffer;
  size_t min_chars;
  double threshold;
  int multibyte_enabled;
  int interpreted_surfaces;
  int ambiguous_mode;
  int filtering;
  int test_garbageness;
  int termination_strictness;
};
</programlisting>
<para>
Analyser options, a part of analyser state.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>int <structfield>const_buffer</structfield></term>
<listitem><simpara> Treat buffer as const?  Otherwise its content can be,
               and probably will be, modified.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>min_chars</structfield></term>
<listitem><simpara> Minimal number significant characters.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="double">double</link> <structfield>threshold</structfield></term>
<listitem><simpara> Minimal ratio between winner and the second.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>multibyte_enabled</structfield></term>
<listitem><simpara> Check for multibyte encodings?
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>interpreted_surfaces</structfield></term>
<listitem><simpara> Allow surfaces causing fundamental reinterpretation?
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>ambiguous_mode</structfield></term>
<listitem><simpara> Ambiguous mode?
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>filtering</structfield></term>
<listitem><simpara> Allow binary and box-drawing filters?
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>test_garbageness</structfield></term>
<listitem><simpara> Do test garbageness?
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>termination_strictness</structfield></term>
<listitem><simpara> Disallow broken multibyte sequences at buffer end?
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaAnalyserState"/>struct EncaAnalyserState</title>
<programlisting>struct EncaAnalyserState {

  /* Language data. */
  const EncaLanguageInfo *lang;
  size_t ncharsets;
  int *charsets;
  /* Analyser state. */
  EncaErrno gerrno;
  size_t size;
  unsigned char *buffer;
  EncaEncoding result;
  size_t *counts;
  size_t bin;
  size_t up;
  double *ratings;
  size_t *order;
  size_t size2;
  unsigned char *buffer2;
  /* Double-UTF-8 data. */
  EncaUTFCheckData *utfch;
  int *utfbuf;
  /* Pair frequency data */
  unsigned char *pair2bits;
  size_t *bitcounts;
  size_t *pairratings;
  /* Options. */
  EncaAnalyserOptions options;
};
</programlisting>
<para>
The internal analyser state.
</para>
<para>
Passed as an opaque object (`this') to analyser calls.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>const <link linkend="EncaLanguageInfo">EncaLanguageInfo</link> *<structfield>lang</structfield></term>
<listitem><simpara> Language informations.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>ncharsets</structfield></term>
<listitem><simpara> Number of 8bit charsets in this language.
            (Equal to <parameter>lang</parameter>-&gt;ncharsets.)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int *<structfield>charsets</structfield></term>
<listitem><simpara> 8bit charset id's [<parameter>ncharsets</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaErrno">EncaErrno</link> <structfield>gerrno</structfield></term>
<listitem><simpara> Guessing gerrno.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>size</structfield></term>
<listitem><simpara> Size of buffer.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char *<structfield>buffer</structfield></term>
<listitem><simpara> Buffer whose encoding is to be detected [<parameter>size</parameter>].
        (Owned by outer world.)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaEncoding">EncaEncoding</link> <structfield>result</structfield></term>
<listitem><simpara> Result returned to caller.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> *<structfield>counts</structfield></term>
<listitem><simpara> Character counts [0x100].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>bin</structfield></term>
<listitem><simpara> Number of `binary' characters.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>up</structfield></term>
<listitem><simpara> Number of 8bit characters.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="double">double</link> *<structfield>ratings</structfield></term>
<listitem><simpara> 8bit charset ratings [<parameter>ncharsets</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> *<structfield>order</structfield></term>
<listitem><simpara> Charset indices (not id's) sorted by ratings in descending order
        [ncharsets].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>size2</structfield></term>
<listitem><simpara> Size of buffer2.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char *<structfield>buffer2</structfield></term>
<listitem><simpara> A temporary secondary buffer [<parameter>size2</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaUTFCheckData">EncaUTFCheckData</link> *<structfield>utfch</structfield></term>
<listitem><simpara> Double-UTF-8 test data [<parameter>ncharsets</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int *<structfield>utfbuf</structfield></term>
<listitem><simpara> Double-UTF-8 buffer for various UCS-2 character counting [0x10000].
         (Magic: see <link linkend="mark-scratch-buffer">mark_scratch_buffer</link>() for description.)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char *<structfield>pair2bits</structfield></term>
<listitem><simpara> Character pair map to charsets [0x100000] (indexed
            0x100*first + second).  Each bit corresponds to one charset,
            when set, the pair is `good' for the given charset.  The
            type is char, so it breaks for <parameter>ncharsets</parameter> &gt; 8, but it should
            not be accessed from outer world, so it can be easily enlarged
            to more bits.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> *<structfield>bitcounts</structfield></term>
<listitem><simpara> Counts for each possible bit combinations in <parameter>pair2bits</parameter>
            [0x1 &lt;&lt; ncharsets].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> *<structfield>pairratings</structfield></term>
<listitem><simpara> Counts of `good' pairs per charset [<parameter>ncharsets</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaAnalyserOptions">EncaAnalyserOptions</link> <structfield>options</structfield></term>
<listitem><simpara> Analyser options.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaCharsetInfo"/>struct EncaCharsetInfo</title>
<programlisting>struct EncaCharsetInfo {

  int enca;
  int rfc1345;
  int cstocs;
  int iconv;
  const char *human;
  unsigned int flags;
  unsigned int nsurface;
};
</programlisting>
<para>
General charset informnations.
</para>
<para>
All the int fields are indices in <link linkend="ALIAS-LIST-CAPS">ALIAS_LIST</link>[].</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>int <structfield>enca</structfield></term>
<listitem><simpara> Default, implicit name in enca.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>rfc1345</structfield></term>
<listitem><simpara> RFC1345 charset name.
         (For charsets not in RFC1345, some canonical name is invented.)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>cstocs</structfield></term>
<listitem><simpara> Cstocs charset name or -1.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>iconv</structfield></term>
<listitem><simpara> Iconv charset name or -1.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const char *<structfield>human</structfield></term>
<listitem><simpara> Human comprehensible description.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned int <structfield>flags</structfield></term>
<listitem><simpara> Charset properties (7bit, 8bit, multibyte, ...).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned int <structfield>nsurface</structfield></term>
<listitem><simpara> Natural surface (`implied' in recode).
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaLanguageInfo"/>struct EncaLanguageInfo</title>
<programlisting>struct EncaLanguageInfo {

  const char *name;
  const char *humanname;
  size_t ncharsets;
  const char *const *csnames;
  const unsigned short int *const *weights;
  const unsigned short int *significant;
  const unsigned char *const *letters;
  const unsigned char **const *pairs;
  long int weight_sum;
  EncaHookFunc hook;
  EncaHookFunc eolhook;
};
</programlisting>
<para>
Language specific data.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>const char *<structfield>name</structfield></term>
<listitem><simpara> Language name, or more precisely, locale name.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const char *<structfield>humanname</structfield></term>
<listitem><simpara> Normal human-readable [English] language name.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>ncharsets</structfield></term>
<listitem><simpara> Number of charsets in this language.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>const char *const *<structfield>csnames</structfield></term>
<listitem><simpara> Charset names [<parameter>ncharsets</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char *const *<structfield>letters</structfield></term>
<listitem><simpara> Characters considered letters (255's have no entry in <parameter>pairs</parameter>,
          zeroes are non-letters aka FILL_NONLETTERs)
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char **const *<structfield>pairs</structfield></term>
<listitem><simpara> Frequent pair table [max number in <parameter>letters</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaHookFunc">EncaHookFunc</link> <structfield>hook</structfield></term>
<listitem><simpara> Hook function (deciding hard cases).
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaHookFunc">EncaHookFunc</link> <structfield>eolhook</structfield></term>
<listitem><simpara> EOL hook function (deciding ambiguous cases based on EOL type).
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaLanguageHookData1CS"/>struct EncaLanguageHookData1CS</title>
<programlisting>struct EncaLanguageHookData1CS {

  const char *name;
  size_t size;
  const unsigned char *list;
  size_t cs;
};
</programlisting>
<para>
Cointainer for data needed by <link linkend="enca-language-hook-ncs">enca_language_hook_ncs</link>().</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>const char *<structfield>name</structfield></term>
<listitem><simpara> Charset name.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>size</structfield></term>
<listitem><simpara> Number of characters in <parameter>list</parameter>.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>unsigned char *<structfield>list</structfield></term>
<listitem><simpara> Extra-important character list for the charset.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>cs</structfield></term>
<listitem><simpara> Charset number.  This is an index in <parameter>analyser</parameter> arrays (like <parameter>charsets</parameter>),
     NOT a charset id.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaLanguageHookDataEOL"/>struct EncaLanguageHookDataEOL</title>
<programlisting>struct EncaLanguageHookDataEOL {

  const char *name;
  EncaSurface eol;
  size_t cs;
};
</programlisting>
<para>
Cointainer for data needed by <link linkend="enca-language-hook-eol">enca_language_hook_eol</link>().</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term>const char *<structfield>name</structfield></term>
<listitem><simpara> Charset name.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="EncaSurface">EncaSurface</link> <structfield>eol</structfield></term>
<listitem><simpara> The corresponding <link linkend="EncaSurface">EncaSurface</link> bit.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>cs</structfield></term>
<listitem><simpara> Charset number.  This is an index in <parameter>analyser</parameter> arrays (like <parameter>charsets</parameter>),
     NOT a charset id.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaHookFunc"/>EncaHookFunc ()</title>
<programlisting>int         (*EncaHookFunc)                 (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Language hook function type.
</para>
<para>
Launches language specific hooks for a particular language.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser state whose charset ratings are to be modified.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero if charset ratigns have been actually modified, zero
otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaGuessFunc"/>EncaGuessFunc ()</title>
<programlisting>int         (*EncaGuessFunc)                (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Special (multibyte) encoding check function type.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser state whose buffer should be checked.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero if analyser-&gt;result has been set, zero otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EncaUTFCheckData"/>struct EncaUTFCheckData</title>
<programlisting>struct EncaUTFCheckData {

  double rating;
  size_t size;
  int result;
  int *ucs2;
  int *weights;
};
</programlisting>
<para>
Data needed by double-UTF-8 check, per language charset.</para>
<para>

</para><variablelist role="struct">
<varlistentry>
<term><link linkend="double">double</link> <structfield>rating</structfield></term>
<listitem><simpara> Total rating for this charset.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term><link linkend="size-t">size_t</link> <structfield>size</structfield></term>
<listitem><simpara> Number of UCS-2 characters.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int <structfield>result</structfield></term>
<listitem><simpara> Nonzero when the sample is probably Doubly-UTF-8 encoded from
         this charset.
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int *<structfield>ucs2</structfield></term>
<listitem><simpara> List of significant UCS-2 characters, in order [<parameter>size</parameter>].
</simpara></listitem>
</varlistentry>
<varlistentry>
<term>int *<structfield>weights</structfield></term>
<listitem><simpara> Weights for double-UTF-8 check [<parameter>size</parameter>].  Positive means normal
          UTF-8, negative doubly-encoded.
</simpara></listitem>
</varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="ELEMENTS-CAPS"/>ELEMENTS()</title>
<programlisting>#define ELEMENTS(array) (sizeof(array)/sizeof((array)[0]))
</programlisting>
<para>
Compute the number of elements of a static array.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>array</parameter>&nbsp;:</term>
<listitem><simpara> An array whose size is to be computed.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> the number of elements.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="MAKE-HOOK-LINE-CAPS"/>MAKE_HOOK_LINE()</title>
<programlisting>#define     MAKE_HOOK_LINE(name)</programlisting>
<para>
Ugly code `beautifier' macro for language hooks.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>name</parameter>&nbsp;:</term>
<listitem><simpara> A charset name in C-style identifier suitable form.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="EPSILON-CAPS"/>EPSILON</title>
<programlisting>#define EPSILON 0.000001
</programlisting>
<para>
`Zero' for float comparsion (and to prevent division by zero, etc.).</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="FILL-NONLETTER-CAPS"/>FILL_NONLETTER</title>
<programlisting>#define FILL_NONLETTER '.'
</programlisting>
<para>
Replacement character for non-letters in pair frequencies.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="LF-CAPS"/>LF</title>
<programlisting>#define LF ((unsigned char)'\n')
</programlisting>
<para>
Line feed character (End-of-line on Unix).</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="CR-CAPS"/>CR</title>
<programlisting>#define CR ((unsigned char)'\r')
</programlisting>
<para>
Carriage return character (End-of-line on Macintosh).</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="enca-malloc"/>enca_malloc ()</title>
<programlisting>void*       enca_malloc                     (<link linkend="size-t">size_t</link> size);</programlisting>
<para>
Allocates memory, always successfully (when fails, aborts program).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>size</parameter>&nbsp;:</term>
<listitem><simpara> The number of bytes to allocate.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-realloc"/>enca_realloc ()</title>
<programlisting>void*       enca_realloc                    (void *ptr,
                                             <link linkend="size-t">size_t</link> size);</programlisting>
<para>
Reallocates memory, always successfully (when fails, aborts program).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>ptr</parameter>&nbsp;:</term>
<listitem><simpara> Pointer to block of previously allocated memory.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>size</parameter>&nbsp;:</term>
<listitem><simpara> The number of bytes to resize the block.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-free"/>enca_free()</title>
<programlisting>#define enca_free(ptr) ENCA_STMT_START{ free(ptr); ptr=NULL; }ENCA_STMT_END
</programlisting>
<para>
Frees memory pointed by <parameter>ptr</parameter> with <link linkend="free">free</link>() hack and assigns it a safe value,
thus may be called more than once.
</para>
<para>
<parameter>ptr</parameter> MUST be l-value.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>ptr</parameter>&nbsp;:</term>
<listitem><simpara> Pointer to memory to free.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="NEW-CAPS"/>NEW()</title>
<programlisting>#define NEW(type,n) ((type*)enca_malloc((n)*sizeof(type)))
</programlisting>
<para>
An <link linkend="enca-malloc">enca_malloc</link>() wrapper.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara> Data type to allocate.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n</parameter>&nbsp;:</term>
<listitem><simpara> Number of elements to allocate.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Pointer to the newly allocated memory.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="RENEW-CAPS"/>RENEW()</title>
<programlisting>#define RENEW(ptr,type,n) ((type*)enca_realloc((ptr),(n)*sizeof(type)))
</programlisting>
<para>
An <link linkend="enca-realloc">enca_realloc</link>() wrapper.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>ptr</parameter>&nbsp;:</term>
<listitem><simpara> Pointer to already allocate memory or <link linkend="NULL-CAPS">NULL</link>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>type</parameter>&nbsp;:</term>
<listitem><simpara> Data type to allocate.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>n</parameter>&nbsp;:</term>
<listitem><simpara> Number of elements to resize the memory to.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Pointer to the reallocated memory (or pointer safe to call <link linkend="free">free</link>()
on when <parameter>n</parameter> is zero).
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-strdup"/>enca_strdup ()</title>
<programlisting>char*       enca_strdup                     (const char *s);</programlisting>
<para>
Duplicates string.
</para>
<para>
Will be defined as <link linkend="strdup">strdup</link>() when system provides it.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>s</parameter>&nbsp;:</term>
<listitem><simpara> A string.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The newly allocated string copy.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-strstr"/>enca_strstr ()</title>
<programlisting>const char* enca_strstr                     (const char *haystack,
                                             const char *needle);</programlisting>
<para>
Finds occurence of a substring in a string.
</para>
<para>
Will be defined as <link linkend="strstr">strstr</link>() when system provides it.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>haystack</parameter>&nbsp;:</term>
<listitem><simpara> A string where to search.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>needle</parameter>&nbsp;:</term>
<listitem><simpara> A string to find.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Pointer to the first occurence of <parameter>needle</parameter> in <parameter>haystack</parameter>; <link linkend="NULL-CAPS">NULL</link> if
         not found.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-stpcpy"/>enca_stpcpy ()</title>
<programlisting>char*       enca_stpcpy                     (char *dest,
                                             const char *src);</programlisting>
<para>
Appends a string to the end of another strings, returning pointer to
the terminating zero byte.
</para>
<para>
Will be defined as <link linkend="stpcpy">stpcpy</link>() when system provides it.
</para>
<para>
Caller is responisble for providing <parameter>dest</parameter> long enough to hold the result.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>dest</parameter>&nbsp;:</term>
<listitem><simpara> A string.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>src</parameter>&nbsp;:</term>
<listitem><simpara> A string to append.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Pointer to the terminating zero byte of resulting string.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-strconcat"/>enca_strconcat ()</title>
<programlisting>char*       enca_strconcat                  (const char *str,
                                             ...);</programlisting>
<para>
Concatenates arbitrary (but at least one) number of strings.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>str</parameter>&nbsp;:</term>
<listitem><simpara> A string.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&nbsp;:</term>
<listitem><simpara> A <link linkend="NULL-terminated">NULL-terminated</link> list of string to append.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> All the strings concatenated together.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-strappend"/>enca_strappend ()</title>
<programlisting>char*       enca_strappend                  (char *str,
                                             ...);</programlisting>
<para>
Appends arbitrary number of strings to a string.
</para>
<para>
The string <parameter>str</parameter> is destroyed (reallocated), the others are kept.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>str</parameter>&nbsp;:</term>
<listitem><simpara> A string.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>...</parameter>&nbsp;:</term>
<listitem><simpara> A <link linkend="NULL-terminated">NULL-terminated</link> list of string to append.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> All the strings concatenated together.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-csname"/>enca_csname()</title>
<programlisting>#define enca_csname(cs) enca_charset_name((cs), ENCA_NAME_STYLE_ENCA)
</programlisting>
<para>
A shorthand for printing names with <link linkend="ENCA-NAME-STYLE-ENCA-CAPS">ENCA_NAME_STYLE_ENCA</link>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>cs</parameter>&nbsp;:</term>
<listitem><simpara> A charset id.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-name-to-charset"/>enca_name_to_charset ()</title>
<programlisting>int         enca_name_to_charset            (const char *csname);</programlisting>
<para>
Transforms charset name to numeric charset id.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>csname</parameter>&nbsp;:</term>
<listitem><simpara> The charset name.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The charset id; <link linkend="ENCA-CS-UNKNOWN-CAPS">ENCA_CS_UNKNOWN</link> when the name is not recognized.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-name-to-surface"/>enca_name_to_surface ()</title>
<programlisting><link linkend="EncaSurface">EncaSurface</link> enca_name_to_surface            (const char *sname);</programlisting>
<para>
Transforms surface name to numeric surface id.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>sname</parameter>&nbsp;:</term>
<listitem><simpara> The surface name.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The surface id; <literal>ENCA_SURFACE_UNKNOWN</literal> when the name is not
recognized.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-language-init"/>enca_language_init ()</title>
<programlisting>int         enca_language_init              (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             const char *langname);</programlisting>
<para>
Initializes analyser for language <parameter>langname</parameter>.
</para>
<para>
Assumes <parameter>analyser</parameter> is unitinialized, calling with an initialized <parameter>analyser</parameter>
leads to memory leak.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state to be initialized for this language.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>langname</parameter>&nbsp;:</term>
<listitem><simpara> Two-letter ISO-639 language code.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero on success, zero otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-language-destroy"/>enca_language_destroy ()</title>
<programlisting>void        enca_language_destroy           (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Destroys the language part of analyser state <parameter>analyser</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state whose language part should be destroyed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-get-charset-similarity-matrix"/>enca_get_charset_similarity_matrix ()</title>
<programlisting><link linkend="double">double</link>*     enca_get_charset_similarity_matrix
                                            (const <link linkend="EncaLanguageInfo">EncaLanguageInfo</link> *lang);</programlisting>
<para>
Computes character weight similarity matrix for language <parameter>lang</parameter>.
</para>
<para>
sim[i,j] is normalized to sim[i,i] thus:
- a row i contains ,probabilities` different languages will look like the
  i-th one
- a column i contains ,probabilities` the i-th language will look like
  the other languages.
</para>
<para>
For all practical applications, the higher one of sim[i,j] and sim[j,i]
is important.
</para>
<para>
Note: this is not used anywhere, only by simtable.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>lang</parameter>&nbsp;:</term>
<listitem><simpara> A language.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The matrix, its size is determined by <parameter>lang</parameter>-&gt;ncharsets; <link linkend="NULL-CAPS">NULL</link>
         for language with no charsets.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-charsets-subset-identical"/>enca_charsets_subset_identical ()</title>
<programlisting>int         enca_charsets_subset_identical  (int charset1,
                                             int charset2,
                                             const <link linkend="size-t">size_t</link> *counts);</programlisting>
<para>
Checks whether all characters with nonzero count have the same meaning
in both charsets.
</para>
<para>
In other words, it checks whether conversion of sample containing only
these characters from <parameter>charset1</parameter> to <parameter>charset2</parameter> would be identity.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>charset1</parameter>&nbsp;:</term>
<listitem><simpara> A charset.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>charset2</parameter>&nbsp;:</term>
<listitem><simpara> Another charset.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>counts</parameter>&nbsp;:</term>
<listitem><simpara> An array of size 0x100 containing character counts.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero if charsets are identical on the subset, zero otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-filter-boxdraw"/>enca_filter_boxdraw ()</title>
<programlisting><link linkend="size-t">size_t</link>      enca_filter_boxdraw             (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             unsigned char fill_char);</programlisting>
<para>
Runs boxdrawing characters filter on <parameter>buffer</parameter> for each charset in <parameter>language</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser whose charsets should be considered for filtration.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>fill_char</parameter>&nbsp;:</term>
<listitem><simpara> Replacement character for filtered bytes.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Number of characters filtered out.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-language-hook-ncs"/>enca_language_hook_ncs ()</title>
<programlisting>int         enca_language_hook_ncs          (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             <link linkend="size-t">size_t</link> ncs,
                                             <link linkend="EncaLanguageHookData1CS">EncaLanguageHookData1CS</link> *hookdata);</programlisting>
<para>
Decide between two charsets differing only in a few characters.
</para>
<para>
If the two most probable charsets correspond to <parameter>hookdata</parameter> charsets,
give the characters they differ half the weight of all other characters
together, thus allowing to decide between the two very similar charsets.
</para>
<para>
It also recomputes <parameter>order</parameter> when something changes.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser whose charset ratings are to be modified.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ncs</parameter>&nbsp;:</term>
<listitem><simpara> The number of charsets.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hookdata</parameter>&nbsp;:</term>
<listitem><simpara> What characters of which charsets should be given the extra
           weight.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero when <parameter>ratings</parameter> were actually modified, nonzero otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-language-hook-eol"/>enca_language_hook_eol ()</title>
<programlisting>int         enca_language_hook_eol          (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser,
                                             <link linkend="size-t">size_t</link> ncs,
                                             <link linkend="EncaLanguageHookDataEOL">EncaLanguageHookDataEOL</link> *hookdata);</programlisting>
<para>
Decide between two charsets differing only in EOL type or other surface.
</para>
<para>
The (surface mask, charset) pairs are scanned in order. If a matching
surface is found, ratings of all other charsets in the list are zeroed.
So you can place a surface mask of all 1s at the end to match when nothing
else matches.
</para>
<para>
All the charsets have to have the same rating, or nothing happens.
</para>
<para>
It also recomputes <parameter>order</parameter> when something changes.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser whose charset ratings are to be modified.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>ncs</parameter>&nbsp;:</term>
<listitem><simpara> The number of charsets.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>hookdata</parameter>&nbsp;:</term>
<listitem><simpara> What characters of which charsets should be decided with based
           on the EOL type.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero when <parameter>ratings</parameter> were actually modified, nonzero otherwise.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-guess-init"/>enca_guess_init ()</title>
<programlisting>void        enca_guess_init                 (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Allocates and initializes analyser state, sets options to defaults.
</para>
<para>
Assumes <parameter>analyser</parameter> is unitinialized, calling with an initialized <parameter>analyser</parameter>
leads to memory leak, but <parameter>analyser</parameter>-&gt;lang must be already initialized.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser to initialize.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-guess-destroy"/>enca_guess_destroy ()</title>
<programlisting>void        enca_guess_destroy              (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Frees memory owned by analyser state.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyser to destroy.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-eol-surface"/>enca_eol_surface ()</title>
<programlisting><link linkend="EncaSurface">EncaSurface</link> enca_eol_surface                (unsigned char *buffer,
                                             <link linkend="size-t">size_t</link> size,
                                             const <link linkend="size-t">size_t</link> *counts);</programlisting>
<para>
Find EOL type of sample in <parameter>buffer</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>buffer</parameter>&nbsp;:</term>
<listitem><simpara> A buffer whose EOL type is to be detected.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>size</parameter>&nbsp;:</term>
<listitem><simpara> Size of <parameter>buffer</parameter>.
</simpara></listitem></varlistentry>
<varlistentry><term><parameter>counts</parameter>&nbsp;:</term>
<listitem><simpara> Character counts.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> The EOL surface flags.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-find-max-sec"/>enca_find_max_sec ()</title>
<programlisting>void        enca_find_max_sec               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Updates <parameter>analyser</parameter>-&gt;order according to charset <parameter>ratings</parameter>.
</para>
<para>
XXX: This should be stable sort.  The ordering is defined by
data/&lt;lang&gt;/&lt;lang&gt;.h header file which is in turn defined by odering in
the appropriate script (doit.sh).  Silly.
</para>
<para>
Must not be called with <parameter>analyser</parameter> with no regular charsets.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> An analyser.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-BE-CAPS"/>ENCA_LANGUAGE_BE</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_BE;
</programlisting>
<para>
Belarussian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-BG-CAPS"/>ENCA_LANGUAGE_BG</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_BG;
</programlisting>
<para>
Bulgarian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-CS-CAPS"/>ENCA_LANGUAGE_CS</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_CS;
</programlisting>
<para>
Czech language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-ET-CAPS"/>ENCA_LANGUAGE_ET</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_ET;
</programlisting>
<para>
Estonian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-HR-CAPS"/>ENCA_LANGUAGE_HR</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_HR;
</programlisting>
<para>
Croatian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-HU-CAPS"/>ENCA_LANGUAGE_HU</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_HU;
</programlisting>
<para>
Hungarian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-LT-CAPS"/>ENCA_LANGUAGE_LT</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_LT;
</programlisting>
<para>
Lithuanian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-LV-CAPS"/>ENCA_LANGUAGE_LV</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_LV;
</programlisting>
<para>
Latvian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-PL-CAPS"/>ENCA_LANGUAGE_PL</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_PL;
</programlisting>
<para>
Polish language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-RU-CAPS"/>ENCA_LANGUAGE_RU</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_RU;
</programlisting>
<para>
Russian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-SK-CAPS"/>ENCA_LANGUAGE_SK</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_SK;
</programlisting>
<para>
Slovak language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-SL-CAPS"/>ENCA_LANGUAGE_SL</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_SL;
</programlisting>
<para>
Slovene language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="ENCA-LANGUAGE-UK-CAPS"/>ENCA_LANGUAGE_UK</title>
<programlisting>extern const EncaLanguageInfo ENCA_LANGUAGE_UK;
</programlisting>
<para>
Ukrainian language.
</para>
<para>
Everything the world out there needs to know about this language.</para>
<para>

</para></refsect2>
<refsect2>
<title><anchor id="enca-double-utf8-init"/>enca_double_utf8_init ()</title>
<programlisting>void        enca_double_utf8_init           (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Initializes double-UTF-8 check.
</para>
<para>
In fact it initializes the fields to <link linkend="NULL-CAPS">NULL</link>'s, they are actually initialized
only when needed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state to be initialized.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-double-utf8-destroy"/>enca_double_utf8_destroy ()</title>
<programlisting>void        enca_double_utf8_destroy        (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Destroys the double-UTF-8 check part of analyser state <parameter>analyser</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state whose double-UTF-8 check part should be destroyed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-pair-init"/>enca_pair_init ()</title>
<programlisting>void        enca_pair_init                  (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Initializes pair statistics data.
</para>
<para>
In fact it just sets everything to <link linkend="NULL-CAPS">NULL</link>, to be initialized when needed.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state to be initialized.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-pair-destroy"/>enca_pair_destroy ()</title>
<programlisting>void        enca_pair_destroy               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Destroys the pair statistics part of analyser state <parameter>analyser</parameter>.</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analyzer state whose pair statistics part should be destroyed.
</simpara></listitem></varlistentry>
</variablelist></refsect2>
<refsect2>
<title><anchor id="enca-pair-analyse"/>enca_pair_analyse ()</title>
<programlisting>int         enca_pair_analyse               (<link linkend="EncaAnalyserState">EncaAnalyserState</link> *analyser);</programlisting>
<para>
Performs pair-frequency based analysis, provided that the language supports
it (does nothing otherwise).</para>
<para>

</para><variablelist role="params">
<varlistentry><term><parameter>analyser</parameter>&nbsp;:</term>
<listitem><simpara> Analysed containing the sample for pair frequency analysis.
</simpara></listitem></varlistentry>
<varlistentry><term><emphasis>Returns</emphasis> :</term><listitem><simpara> Nonzero when the character set was succesfully determined,
         <parameter>analyser</parameter>-&gt;<parameter>result</parameter>.<parameter>charset</parameter> is then directly modified.
</simpara></listitem></varlistentry>
</variablelist></refsect2>

</refsect1>




</refentry>
